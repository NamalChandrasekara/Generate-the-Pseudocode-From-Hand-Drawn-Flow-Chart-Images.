# -*- coding: utf-8 -*-
"""shape_5thJune.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1993NFCj_DxRk00lDEm7CJ4bydYhidNIw
"""

from google.colab import drive
drive.mount('/content/drive')

import torch
import torchvision.transforms.functional as F
from torchvision.models.detection.faster_rcnn import FastRCNNPredictor
from torchvision.models.detection import fasterrcnn_resnet50_fpn
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Define the label map
label_map = {
    "arrow_line_down": 1,
    "decision": 2,
    "process": 3,
    "start_end": 4,
    "arrow_line_left": 5,
    "arrow_line_right": 6,
    "arrow_line_up": 8,
    "print": 9,
    "scan": 7  # Add all other unique labels you found here
}
reverse_label_map = {v: k for k, v in label_map.items()}

# Load the pre-trained model
num_classes = len(label_map) + 1  # Include background as class 0
model = fasterrcnn_resnet50_fpn(pretrained=True)
in_features = model.roi_heads.box_predictor.cls_score.in_features
model.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)

# Load the trained model weights
model.load_state_dict(torch.load('/content/drive/MyDrive/faster_rcnn_flowchart.pth', map_location=torch.device('cpu')))  # Update the path
model.eval()

# Move model to the device
device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
model.to(device)

# Preprocess the image
def preprocess_image(image_path):
    img = Image.open(image_path).convert("RGB")
    img_tensor = F.to_tensor(img)
    return img_tensor

# Postprocess the output
def postprocess_output(prediction, threshold=0.5):
    boxes = prediction[0]['boxes']
    labels = prediction[0]['labels']
    scores = prediction[0]['scores']

    # Filter out low confidence predictions
    boxes = boxes[scores > threshold]
    labels = labels[scores > threshold]

    return boxes, labels

# Function to perform inference and extract shapes and coordinates
def detect_shapes(image_path):
    # Preprocess the image
    img_tensor = preprocess_image(image_path)
    img_tensor = img_tensor.unsqueeze(0)  # Add batch dimension
    img_tensor = img_tensor.to(device)

    # Get predictions
    with torch.no_grad():
        prediction = model(img_tensor)

    # Postprocess the output
    boxes, labels = postprocess_output(prediction, threshold=0.5)
    boxes = boxes.cpu()
    labels = labels.cpu()

    # Output the shapes with their coordinates
    ex_shape = []
    ex_coor = []

    for i in range(len(boxes)):
        box = boxes[i].numpy()
        label = labels[i].item()
        shape_name = reverse_label_map[label]
        coordinates = {
            "xmin": int(box[0]),
            "ymin": int(box[1]),
            "xmax": int(box[2]),
            "ymax": int(box[3])
        }
        ex_shape.append(shape_name)
        ex_coor.append(coordinates)

    return ex_shape, ex_coor